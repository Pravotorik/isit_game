// Данные для вопросов (на основе предоставленного текста)
const questionsData = [
    {
        question: "Что из перечисленного НЕ является общим свойством объектов реального и техногенного мира?",
        answers: [
            "НАЛИЧИЕ СТАТИКИ (СТРУКТУРЫ, ИНТЕГРАЦИИ)",
            "МНОГООБРАЗИЕ И МНОГОВАРИАНТНОСТЬ",
            "ПОЛНАЯ ПРЕДСКАЗУЕМОСТЬ ПОВЕДЕНИЯ",
            "НАЛИЧИЕ КОНТУРА УПРАВЛЕНИЯ"
        ],
        correct: 2,
        explanation: "Для сложных систем присуща СЛАБАЯ предсказуемость поведения, а не полная предсказуемость."
    },
    {
        question: "Что из перечисленного относится к признакам СТРУКТУРНОЙ сложности объекта?",
        answers: [
            "Множество состояний и правила перехода между ними",
            "Число элементов, число и разнообразие типов связей, количество иерархических уровней",
            "Степень неопределённости характеристик и правил функционирования",
            "Гибкость реакций на заранее неизвестные воздействия среды"
        ],
        correct: 1,
        explanation: "Структурная сложность определяется по числу элементов, числу и разнообразию типов связей, количеству иерархических уровней и общему числу подсистем."
    },
    {
        question: "Какой из перечисленных типов связей НЕ считается основным при определении структурной сложности?",
        answers: [
            "Структурные (в том числе иерархические)",
            "Функциональные",
            "Каузальные (причинно-следственные)",
            "Эмоциональные"
        ],
        correct: 3,
        explanation: "Основными типами связей считаются: структурные, функциональные, каузальные, информационные, пространственно-временные. Эмоциональные связи не упоминаются."
    },
    {
        question: "Что определяет сложность ФУНКЦИОНИРОВАНИЯ (поведения) объекта?",
        answers: [
            "Количество элементов системы",
            "Иерархическое построение системы",
            "Множество состояний, правила перехода из состояния в состояние, воздействие объекта на среду и среды на объект",
            "Наличие контура управления"
        ],
        correct: 2,
        explanation: "Сложность функционирования определяется характеристиками: множества состояний, правил перехода из состояния в состояние, воздействия объекта на среду и среды на объект."
    },
    {
        question: "Какая подсистема сложного объекта отвечает за поддержание динамического равновесия внутри системы и регулирование потоков энергии и вещества?",
        answers: [
            "Решающая подсистема",
            "Информационная подсистема",
            "Гомеостазная подсистема",
            "Адаптивная подсистема"
        ],
        correct: 2,
        explanation: "Гомеостазная подсистема поддерживает динамическое равновесие внутри систем и регулирует потоки энергии и вещества в подсистемах."
    },
    {
        question: "Какая подсистема сложного объекта накапливает опыт в процессе обучения для улучшения структуры и функций системы?",
        answers: [
            "Решающая подсистема",
            "Информационная подсистема",
            "Управляющая подсистема",
            "Адаптивная подсистема"
        ],
        correct: 3,
        explanation: "Адаптивная подсистема накапливает опыт в процессе обучения для улучшения структуры и функций системы."
    },
    {
        question: "Какой из перечисленных факторов НЕ присущ сложным системам?",
        answers: [
            "Слабая предсказуемость поведения",
            "Скрытность",
            "Разнообразные состояния",
            "Полная прозрачность и открытость"
        ],
        correct: 3,
        explanation: "Для сложных систем присущи: слабая предсказуемость, скрытность, разнообразные состояния. Полная прозрачность не упоминается как их свойство."
    },
    {
        question: "Что из перечисленного относится к ВСПОМОГАТЕЛЬНЫМ (обязательным) подсистемам сложных объектов?",
        answers: [
            "Решающая подсистема",
            "Подсистемы идентификации объектов и ресурсов",
            "Информационная подсистема",
            "Адаптивная подсистема"
        ],
        correct: 1,
        explanation: "Вспомогательные подсистемы: идентификации объектов и ресурсов; контроля и устранения ошибок; настроек для оптимизации производительности; хранения информации (реестр)."
    },
    {
        question: "Что такое сложность РАЗВИТИЯ объекта?",
        answers: [
            "Определяется числом элементов и связей",
            "Определяется гибкостью реакций на неизвестные воздействия",
            "Определяется характеристиками эволюционных или скачкообразных процессов",
            "Определяется количеством иерархических уровней"
        ],
        correct: 2,
        explanation: "Сложность развития определяемая характеристиками эволюционных или скачкообразных процессов."
    },
    {
        question: "Что характеризует сложность ВЫБОРА ПОВЕДЕНИЯ объекта?",
        answers: [
            "Количество элементов в системе",
            "Многоальтернативность ситуаций, когда выбор определяется целью объекта и гибкостью реакций",
            "Количество и разнообразие типов связей",
            "Наличие событийной структуры"
        ],
        correct: 1,
        explanation: "Сложность выбора поведения возникает в многоальтернативных ситуациях, когда выбор поведения определяется целью объекта, гибкостью реакций на заранее неизвестные воздействия среды."
    },
    {
    question: "Что является главным элементом определения автоматизированной информационной системы (АИС)?",
    answers: [
        "Наличие вычислительного и коммуникационного оборудования",
        "Поддержка динамической информационной модели предметной области",
        "Присутствие системного персонала",
        "Использование специализированного программного обеспечения"
    ],
    correct: 1,
    explanation: "Главный элемент определения АИС - поддержка динамической информационной модели 'некоторой части реального мира'. Это свойственно любой ИС независимо от используемых технологий."
},
{
    question: "Какой компонент ИС обеспечивает оптимальное взаимодействие ИТ, функциональных подсистем и специалистов в течение жизненного цикла?",
    answers: [
        "Информационные технологии (ИТ)",
        "Функциональные подсистемы и приложения",
        "Управление ИС",
        "Среда взаимодействия (аппаратная составляющая)"
    ],
    correct: 2,
    explanation: "Управление ИС - это компонент, который обеспечивает оптимальное взаимодействие ИТ, функциональных подсистем и связанных с ними специалистов, развитие их в течение жизненного цикла ИС."
},
{
    question: "Что понимается под 'средой существования и разработки бизнес-приложений' в компонентной структуре ИС?",
    answers: [
        "Структурированные кабельные сети и коммутационное оборудование",
        "ПЛАТФОРМА (например, Lotus Notes, WebCT, 1С-Бухгалтерия)",
        "Системные программы, обеспечивающие функционирование аппаратной составляющей",
        "Бизнес-приложения по направлениям деятельности организации"
    ],
    correct: 1,
    explanation: "Среда существования и разработки бизнес-приложений - это ПЛАТФОРМА, на которой создаются и функционируют приложения, такие как Lotus Notes, WebCT, 1С-Бухгалтерия."
    }, 
{
    question: "Что принципиально важно отражает определение информационной системы с точки зрения бизнеса?",
    answers: [
        "Технологическую составляющую и аппаратное обеспечение",
        "Организационную и управленческую природу информационных систем",
        "Программные средства и лингвистические компоненты",
        "Информационные ресурсы и базы данных"
    ],
    correct: 1,
    explanation: "Определение информационной системы с точки зрения бизнеса принципиально важно, поскольку отражает организационную и управленческую природу информационных систем."
},
{
    question: "В чем проявляется управленческая природа информационной системы?",
    answers: [
        "В том, что ИС автоматизирует физические процессы на производстве",
        "В том, что ИС хранит документацию организации",
        "В том, что ИС предоставляет возможности для анализа последствий управленческих решений без натурного эксперимента",
        "В том, что ИС заменяет человеческий труд в организации"
    ],
    correct: 2,
    explanation: "Управленческая природа заключается в том, что ИС предоставляет возможности для анализа и оценки последствий различных управленческих решений без проведения натурного эксперимента."
},
{
    question: "Что такое предметная область в контексте информационных систем?",
    answers: [
        "Программное обеспечение, используемое в организации",
        "Часть реального мира, которая подлежит изучению и рассматривается в пределах данного контекста",
        "Техническая инфраструктура информационной системы",
        "Совокупность всех данных, хранящихся в системе"
    ],
    correct: 1,
    explanation: "Предметная область — это часть реального мира, которая подлежит изучению (например, с целью автоматизации организации управления) и рассматриваемая в пределах данного контекста."
},
{
    question: "Что является итогом процесса абстрагирования при изучении предметной области?",
    answers: [
        "Техническое задание на разработку ИС",
        "Модель — упрощенное представление реального объекта",
        "Полная документация по всем процессам",
        "Интерфейс пользователя системы"
    ],
    correct: 1,
    explanation: "Итогом абстрагирования является модель – упрощенное представление реального объекта, сохранившее все качества и характеристики, представляющие интерес с точки зрения целевых установок исследования."
},
{
    question: "Какие из перечисленных объектов относятся к НЕматериализуемым сущностям в предметной области?",
    answers: [
        "Станок и деталь",
        "Товар и оборудование",
        "Имена и понятия",
        "Здания и сооружения"
    ],
    correct: 2,
    explanation: "К нематериализуемым сущностям относятся: имена (например, наименование организации) и понятия (например, 'скидка', 'надежность')."
},
{
    question: "Что такое ситуации в предметной области?",
    answers: [
        "Технические сбои в работе системы",
        "Взаимосвязи, выражающие взаимоотношения между объектами",
        "Периодические отчеты, генерируемые системой",
        "Изменения в штатном расписании организации"
    ],
    correct: 1,
    explanation: "Ситуации – это взаимосвязи, выражающие взаимоотношения между объектами. Они описываются посредством высказываний о предметной области с использованием формальной логики."
    },
{
    question: "Что такое экономическая информационная система (ЭИС)?",
    answers: [
        "Система для автоматизации бухгалтерского учёта",
        "Система, предназначенная для сбора, хранения, обработки и представления экономической информации в целях управления социально-экономическими процессами",
        "База данных финансовых транзакций организации",
        "Программное обеспечение для анализа рынка"
    ],
    correct: 1,
    explanation: "ЭИС — это система, предназначенная для сбора, хранения, обработки и представления экономической информации в целях управления социально-экономическими процессами и коллективами людей в производственной и непроизводственной сфере."
},
{
    question: "Какая характеристика НЕ относится к экономической информации?",
    answers: [
        "Большие объёмы данных",
        "Преобладание непрерывных физических величин (температура, давление)",
        "Многообразие источников и потребителей",
        "Значительный удельный вес рутинных процедур при обработке"
    ],
    correct: 1,
    explanation: "Экономическая информация состоит в основном из алфавитно-цифровых знаков с дискретным представлением численных величин, а не непрерывных физических величин."
},
{
    question: "Что включает в себя внемашинное информационное обеспечение?",
    answers: [
        "Только компьютерное оборудование и серверы",
        "Только программное обеспечение для обработки данных",
        "Внемашинную информационную базу и средства её ведения",
        "Только сети передачи данных"
    ],
    correct: 2,
    explanation: "Внемашинное информационное обеспечение включает внемашинную информационную базу (ИБ) и средства её ведения. Внемашинная ИБ состоит из данных, содержащихся в документах."
},
{
    question: "Какой метод классификации предполагает построение древовидной структуры с отношениями подчинения?",
    answers: [
        "Фасетный метод",
        "Иерархический метод",
        "Матричный метод",
        "Сетевой метод"
    ],
    correct: 1,
    explanation: "Иерархический метод — построение древовидной структуры с отношениями подчинения (класс → подкласс → группа → вид), где каждый объект попадает только в одну группировку."
},
{
    question: "Чем отличается фасетный метод классификации от иерархического?",
    answers: [
        "Фасетный метод проще в реализации",
        "Фасетный метод позволяет объекту входить одновременно в несколько группировок",
        "Фасетный метод использует только цифровые коды",
        "Фасетный метод не требует предварительного анализа объектов"
    ],
    correct: 1,
    explanation: "При фасетном методе объект может входить одновременно в несколько независимых группировок по значениям отдельных фасетов, в отличие от иерархического метода, где объект попадает только в одну группировку."
},
{
    question: "Что такое регистрационный (идентификационный) метод кодирования?",
    answers: [
        "Метод, отражающий все признаки объекта в коде",
        "Присвоение уникального номера объекту (последовательная нумерация или серийные номера)",
        "Метод, основанный только на иерархической классификации",
        "Использование буквенных обозначений вместо цифр"
    ],
    correct: 1,
    explanation: "Регистрационный (идентификационный) метод кодирования — это присвоение уникального номера объекту, например, последовательная нумерация или серийные номера."
    },
{
    question: "Какая подсистема ИС предприятия обслуживает 'производственный' уровень?",
    answers: [
        "Системы диалоговой обработки запросов (TPS)",
        "Системы работы знания (KWS)",
        "Управляющие информационные системы (MIS)",
        "Системы поддержки выполнения (ESS)"
    ],
    correct: 0,
    explanation: "Системы диалоговой обработки запросов – Transaction Processing Systems (TPS) обслуживают 'производственный' уровень предприятия."
},
{
    question: "Что такое интеграция информационных систем?",
    answers: [
        "Установка нового программного обеспечения",
        "Процесс объединения различных ИС для создания единого информационного пространства",
        "Обучение пользователей работе с системой",
        "Переход на новые аппаратные средства"
    ],
    correct: 1,
    explanation: "Интеграция информационных систем – это процесс объединения различных ИС для создания единого информационного пространства и обеспечения сквозного взаимодействия бизнес-процессов."
},
{
    question: "Какой подход к интеграции предполагает прямое соединение двух систем без посредников?",
    answers: [
        "Интеграция 'по шине сервисов'",
        "Интеграция по типу 'точка-точка'",
        "Сервис-ориентированная архитектура",
        "Микросервисная архитектура"
    ],
    correct: 1,
    explanation: "Интеграция по типу 'точка-точка' — это простейший метод соединения двух систем напрямую, без посредников, для обмена данными и функциями."
},
{
    question: "Что такое корпоративная сервисная шина (ESB)?",
    answers: [
        "Физическая сеть передачи данных",
        "Промежуточное ПО для унифицированного обмена данными между разнородными системами",
        "База данных предприятия",
        "Система управления контентом"
    ],
    correct: 1,
    explanation: "Корпоративная сервисная шина (ESB) – это промежуточное программное обеспечение для унифицированного и гибкого обмена данными между различными, разнородными приложениями и системами на предприятии."
},
{
    question: "Что из перечисленного относится к структурному аспекту моделирования предметной области?",
    answers: [
        "Оценка времени решения задач",
        "Расчет стоимостных затрат на обработку данных",
        "Построение объектной структуры",
        "Анализ рентабельности процессов"
    ],
    correct: 2,
    explanation: "Структурный аспект предполагает построение объектной структуры, функциональной структуры, структуры управления, организационной структуры и технической структуры."
},
{
    question: "Какая нотация используется для детализированного описания бизнес-процессов нижнего уровня?",
    answers: [
        "ER-модель",
        "Диаграмма классов UML",
        "Нотация EPC",
        "Диаграмма развертывания"
    ],
    correct: 2,
    explanation: "Нотация EPC (Event-Driven Process Chain) — это метод графического моделирования, используемый для детализированного описания бизнес-процессов нижнего уровня."
},
{
    question: "Что такое ER-модель?",
    answers: [
        "Модель для описания бизнес-процессов",
        "Семантическая концептуальная модель данных",
        "Модель для проектирования пользовательского интерфейса",
        "Метод оценки эффективности системы"
    ],
    correct: 1,
    explanation: "ER-модель (Entity-Relationship) — это семантическая концептуальная модель данных, независимая от программного обеспечения, предназначенная для логического представления предметной области через сущности, их атрибуты и связи."
}
];

// Данные для карточек
const cardsData = [
    { term: "СЛОЖНОСТЬ", definition: "Многоэлементность, многосвязность и многотипность связей, поведенческая сложность объектов реального и техногенного мира." },
    { term: "СОБЫТИЙНАЯ СТРУКТУРА", definition: "Наличие средств реагирования на предполагаемый событийный спектр в сложных системах." },
    { term: "СТРУКТУРНАЯ СЛОЖНОСТЬ", definition: "Определяется по числу элементов системы, числу и разнообразию типов связей между ними, количеству иерархических уровней и общему числу подсистем." },
    { term: "ГОМЕОСТАЗНАЯ ПОДСИСТЕМА", definition: "Поддерживает динамическое равновесие внутри систем и регулирует потоки энергии и вещества в подсистемах." },
    { term: "АДАПТИВНАЯ ПОДСИСТЕМА", definition: "Накопление опыта в процессе обучения для улучшения структуры и функций системы." },
    { term: "РЕШАЮЩАЯ ПОДСИСТЕМА", definition: "Принимает глобальные решения во взаимодействии с внешней средой и распределяет локальные задания между всеми другими подсистемами." },
    { term: "ИНФОРМАЦИОННАЯ ПОДСИСТЕМА", definition: "Обеспечивает сбор, переработку и передачу информации, необходимой для принятия глобальных решений и выполнения локальных задач." },
    { term: "УПРАВЛЯЮЩАЯ ПОДСИСТЕМА", definition: "Реализует глобальные решения в сложных системах." },
    { 
    term: "ИНФОРМАЦИОННАЯ СИСТЕМА (традиционное определение)", 
    definition: "Взаимосвязанная совокупность средств, методов и персонала, используемых для хранения, обработки и выдачи информации в интересах достижения поставленной цели."
},
{ 
    term: "АВТОМАТИЗИРОВАННАЯ ИНФОРМАЦИОННАЯ СИСТЕМА (АИС)", 
    definition: "Комплекс, включающий вычислительное и коммуникационное оборудование, ПО, лингвистические средства, информационные ресурсы и системный персонал, обеспечивающий поддержку динамической информационной модели некоторой части реального мира."
},
{ 
    term: "ИНФОРМАЦИОННЫЕ ТЕХНОЛОГИИ (в структуре АИС)", 
    definition: "Инфраструктура, обеспечивающая реализацию информационных процессов сбора, обработки, накопления, хранения, поиска и распространения информации для снижения трудоемкости процессов использования информационных ресурсов."
    }, 
{
    term: "ИНФОРМАЦИОННАЯ СИСТЕМА (с точки зрения бизнеса)",
    definition: "Организационное и управленческое решение, основанное на информационных технологиях, предназначенное для работы в любом окружении."
},
{
    term: "ОРГАНИЗАЦИОННАЯ ПРИРОДА ИС",
    definition: "Проявляется в том, что ИС нужна организации для обеспечения информационно-коммуникационной поддержки ее основной и вспомогательной деятельности, являясь частью организационной структуры."
},
{
    term: "УПРАВЛЕНЧЕСКАЯ ПРИРОДА ИС",
    definition: "Заключается в предоставлении возможностей для анализа и оценки последствий различных управленческих решений без проведения натурного эксперимента."
},
{
    term: "ПРЕДМЕТНАЯ ОБЛАСТЬ",
    definition: "Часть реального мира, которая подлежит изучению (например, с целью автоматизации организации управления) и рассматриваемая в пределах данного контекста."
},
{
    term: "АБСТРАГИРОВАНИЕ",
    definition: "Процесс выделения существенных особенностей объекта, отличающих его от всех других объектов, итогом которого является модель предметной области."
},
{
    term: "МОДЕЛЬ ПРЕДМЕТНОЙ ОБЛАСТИ",
    definition: "Упрощенное представление реального объекта, сохранившее все качества и характеристики, представляющие интерес с точки зрения целевых установок исследования."
},
{
    term: "МАТЕРИАЛИЗУЕМЫЕ СУЩНОСТИ",
    definition: "Объекты предметной области, имеющие физическое воплощение (например, станок, деталь, товар, оборудование)."
},
{
    term: "НЕМАТЕРИАЛИЗУЕМЫЕ СУЩНОСТИ",
    definition: "Объекты предметной области, не имеющие физического воплощения: имена (наименования), понятия ('скидка', 'надежность') и ситуации."
    }, 
{
    term: "ЭКОНОМИЧЕСКАЯ ИНФОРМАЦИОННАЯ СИСТЕМА (ЭИС)",
    definition: "Система, предназначенная для сбора, хранения, обработки и представления экономической информации в целях управления социально-экономическими процессами и коллективами людей в производственной и непроизводственной сфере."
},
{
    term: "ПРЕДМЕТНАЯ ОБЛАСТЬ ЭИС",
    definition: "Сфера деятельности, связанная с производственной и финансовой деятельностью организаций, банков, промышленных предприятий, ЖКХ, а также организаций социально-гуманитарной сферы."
},
{
    term: "ЭКОНОМИЧЕСКАЯ ИНФОРМАЦИЯ (ЭИ)",
    definition: "Совокупность новых сведений, отражающих социально-экономические процессы и служащих для управления этими процессами. Характеризуется большими объёмами, многократным повторением циклов обработки и преобладанием алфавитно-цифровых знаков."
},
{
    term: "ВНЕМАШИННОЕ ИНФОРМАЦИОННОЕ ОБЕСПЕЧЕНИЕ",
    definition: "Включает внемашинную информационную базу (данные в документах) и средства её ведения. Решает задачи определения состава информации, выявления её логической структуры и организации хранения и доступа."
},
{
    term: "КЛАССИФИКАЦИЯ",
    definition: "Распределение множества объектов на подмножества по признакам сходства или различия. Основа информационной системы экономического учёта — классификаторы и кодификаторы."
},
{
    term: "ИЕРАРХИЧЕСКИЙ МЕТОД КЛАССИФИКАЦИИ",
    definition: "Построение древовидной структуры с отношениями подчинения (класс → подкласс → группа → вид), где каждый объект попадает только в одну группировку."
},
{
    term: "ФАСЕТНЫЙ МЕТОД КЛАССИФИКАЦИИ",
    definition: "Разбиение множества объектов на независимые подмножества по значениям отдельных фасетов (набор значений признаков классификации), при котором объект может входить одновременно в несколько группировок."
},
{
    term: "КОДИРОВАНИЕ",
    definition: "Присвоение объектам или классификационным группировкам условных обозначений (кодов). Включает классификационные методы (отражают признаки объекта) и регистрационные методы (присваивают уникальные номера)."
    },
{
    question: "Какая подсистема ИС предприятия обслуживает 'производственный' уровень?",
    answers: [
        "Системы диалоговой обработки запросов (TPS)",
        "Системы работы знания (KWS)",
        "Управляющие информационные системы (MIS)",
        "Системы поддержки выполнения (ESS)"
    ],
    correct: 0,
    explanation: "Системы диалоговой обработки запросов – Transaction Processing Systems (TPS) обслуживают 'производственный' уровень предприятия."
},
{
    question: "Что такое интеграция информационных систем?",
    answers: [
        "Установка нового программного обеспечения",
        "Процесс объединения различных ИС для создания единого информационного пространства",
        "Обучение пользователей работе с системой",
        "Переход на новые аппаратные средства"
    ],
    correct: 1,
    explanation: "Интеграция информационных систем – это процесс объединения различных ИС для создания единого информационного пространства и обеспечения сквозного взаимодействия бизнес-процессов."
},
{
    question: "Какой подход к интеграции предполагает прямое соединение двух систем без посредников?",
    answers: [
        "Интеграция 'по шине сервисов'",
        "Интеграция по типу 'точка-точка'",
        "Сервис-ориентированная архитектура",
        "Микросервисная архитектура"
    ],
    correct: 1,
    explanation: "Интеграция по типу 'точка-точка' — это простейший метод соединения двух систем напрямую, без посредников, для обмена данными и функциями."
},
{
    question: "Что такое корпоративная сервисная шина (ESB)?",
    answers: [
        "Физическая сеть передачи данных",
        "Промежуточное ПО для унифицированного обмена данными между разнородными системами",
        "База данных предприятия",
        "Система управления контентом"
    ],
    correct: 1,
    explanation: "Корпоративная сервисная шина (ESB) – это промежуточное программное обеспечение для унифицированного и гибкого обмена данными между различными, разнородными приложениями и системами на предприятии."
},
{
    question: "Что из перечисленного относится к структурному аспекту моделирования предметной области?",
    answers: [
        "Оценка времени решения задач",
        "Расчет стоимостных затрат на обработку данных",
        "Построение объектной структуры",
        "Анализ рентабельности процессов"
    ],
    correct: 2,
    explanation: "Структурный аспект предполагает построение объектной структуры, функциональной структуры, структуры управления, организационной структуры и технической структуры."
},
{
    question: "Какая нотация используется для детализированного описания бизнес-процессов нижнего уровня?",
    answers: [
        "ER-модель",
        "Диаграмма классов UML",
        "Нотация EPC",
        "Диаграмма развертывания"
    ],
    correct: 2,
    explanation: "Нотация EPC (Event-Driven Process Chain) — это метод графического моделирования, используемый для детализированного описания бизнес-процессов нижнего уровня."
},
{
    question: "Что такое ER-модель?",
    answers: [
        "Модель для описания бизнес-процессов",
        "Семантическая концептуальная модель данных",
        "Модель для проектирования пользовательского интерфейса",
        "Метод оценки эффективности системы"
    ],
    correct: 1,
    explanation: "ER-модель (Entity-Relationship) — это семантическая концептуальная модель данных, независимая от программного обеспечения, предназначенная для логического представления предметной области через сущности, их атрибуты и связи."
} 
];

// Данные для сопоставления
const matchingData = [
    { term: "СЛОЖНОСТЬ", definition: "Многоэлементность, многосвязность и многотипность связей" },
    { term: "ГОМЕОСТАЗНАЯ ПОДСИСТЕМА", definition: "Поддерживает динамическое равновесие внутри систем" },
    { term: "СТРУКТУРНАЯ СЛОЖНОСТЬ", definition: "Определяется числом элементов и разнообразием связей" },
    { term: "АДАПТИВНАЯ ПОДСИСТЕМА", definition: "Накопление опыта для улучшения структуры и функций" },
    { term: "СОБЫТИЙНАЯ СТРУКТУРА", definition: "Средства реагирования на предполагаемый событийный спектр" },
    {
    term: "Среда работы пользователей ИС", 
    definition: "Бизнес-приложения по направлениям деятельности организации и информационные сервисы"
},
{
    term: "Среда взаимодействия (программная составляющая)", 
    definition: "Системные программы, обеспечивающие функционирование аппаратной составляющей"
},
{
    term: "Функциональные подсистемы и приложения", 
    definition: "Специализированные программы для обработки и анализа информации в конкретной функциональной области на базе ИТ"
    },
{
    term: "Статические ситуации",
    definition: "Не изменяются во времени: состояния (устойчивые и временные), свойства и отношения"
},
{
    term: "Динамические ситуации", 
    definition: "Изменяются во времени: процессы и события (результаты и происшествия)"
},
{
    term: "Ситуации в предметной области",
    definition: "Взаимосвязи, выражающие взаимоотношения между объектами, описываемые с помощью формальной логики"
},
{
    term: "'Видение' предметной области",
    definition: "Упрощенное представление о какой-то стороне сложного объекта на основе абстрагирования у каждого наблюдателя"
    }, 
{
    term: "Характеристики экономической информации",
    definition: "Большие объёмы, многократное повторение циклов обработки, многообразие источников и потребителей, преобладание алфавитно-цифровых знаков"
},
{
    term: "Средства организации внемашинной ИБ",
    definition: "Система классификации и кодирования, унифицированные системы документации, система организации и ведения документации"
},
{
    term: "Методы кодирования экономической информации",
    definition: "Классификационный (отражает признаки объекта) и регистрационный (присваивает уникальный номер)"
},
{
    term: "Структура кода экономической информации",
    definition: "Может включать классификационную часть (раскрывает признаки объекта) и идентификационную часть (обеспечивает уникальность)"
    }, 
{
    term: "TPS (Transaction Processing Systems)",
    definition: "Системы диалоговой обработки запросов, обслуживающие 'производственный' уровень предприятия"
},
{
    term: "DSS (Decision Support Systems)",
    definition: "Системы поддержки принятия решений, обычно использующие данные других подсистем для аналитической работы"
},
{
    term: "ESS (Executive Support Systems)",
    definition: "Системы поддержки выполнения, главный получатель данных из внешней среды и внутренних систем"
},
{
    term: "Функциональное представление системы",
    definition: "Выделение совокупности функций (целенаправленных действий) системы и её компонентов, направленное на достижение определённой цели"
},
{
    term: "Процессное представление системы",
    definition: "Понимание системного объекта как динамического объекта, характеризующегося последовательностью его состояний во времени"
}
    ];

// Данные для заполнения пропусков
const fillInData = [
    {
        text: "Объекты реального и техногенного мира обладают общими свойствами: СЛОЖНОСТЬ, НАЛИЧИЕ СТАТИКИ, НАЛИЧИЕ ДИНАМИКИ, НАЛИЧИЕ [1], МНОГООБРАЗИЕ И МНОГОВАРИАНТНОСТЬ, НАЛИЧИЕ КОНТУРА УПРАВЛЕНИЯ.",
        blanks: [
            { id: 1, correct: "СОБЫТИЙНОЙ СТРУКТУРЫ", options: ["СОБЫТИЙНОЙ СТРУКТУРЫ", "ИЕРАРХИЧЕСКОГО ПОСТРОЕНИЯ", "ГОМЕОСТАЗНОЙ ПОДСИСТЕМЫ", "АДАПТИВНОЙ ПОДСИСТЕМЫ"] }
        ]
    },
    {
        text: "Структурная сложность определяется по числу элементов системы, числу и разнообразию типов связей между ними, количеству иерархических уровней и общему числу подсистем. Основными типами считаются связи: структурные, функциональные, [1], информационные, пространственно-временные.",
        blanks: [
            { id: 1, correct: "каузальные", options: ["каузальные", "эмоциональные", "технические", "организационные"] }
        ]
    },
    {
        text: "В сложных системах выделяют факторные подсистемы: решающая, информационная, управляющая, [1], адаптивная.",
        blanks: [
            { id: 1, correct: "гомеостазная", options: ["гомеостазная", "вспомогательная", "идентификационная", "контролирующая"] }
        ]
    },
    {
        text: "Сложность функционирования определяется характеристиками: множества состояний, правил перехода из состояние в состояние, воздействие объекта на среду и среды на объект, степень [1] перечисленных характеристик и правил.",
        blanks: [
            { id: 1, correct: "неопределённости", options: ["неопределённости", "предсказуемости", "сложности", "разнообразия"] }
        ]
    },
    {
    text: "Автоматизированная информационная система - комплекс, включающий [1], программное обеспечение, лингвистические средства, [2], а также системный персонал. Он обеспечивает поддержку [3] некоторой части реального мира.",
    blanks: [
        { 
            id: 1, 
            correct: "вычислительное и коммуникационное оборудование", 
            options: ["вычислительное и коммуникационное оборудование", "функциональные подсистемы", "средства управления", "информационные сервисы"] 
        },
        { 
            id: 2, 
            correct: "информационные ресурсы", 
            options: ["информационные ресурсы", "бизнес-приложения", "аппаратную составляющую", "платформу разработки"] 
        },
        { 
            id: 3, 
            correct: "динамической информационной модели", 
            options: ["динамической информационной модели", "статической базы данных", "иерархической структуры", "распределенной сети"] 
        }
    ]
},
{
    text: "В четырехслойной структуре ИС 'среда взаимодействия' состоит из двух составляющих: [1] (программная составляющая) и [2] (аппаратная составляющая).",
    blanks: [
        { 
            id: 1, 
            correct: "системные программы", 
            options: ["системные программы", "бизнес-приложения", "информационные сервисы", "платформа"] 
        },
        { 
            id: 2, 
            correct: "структурированные кабельные сети и оборудование", 
            options: ["структурированные кабельные сети и оборудование", "информационные технологии", "функциональные подсистемы", "управление ИС"] 
        }
    ]
    },
    {
    text: "Информационная система с точки зрения бизнеса представляет собой [1] решение, основанное на информационных технологиях. Это определение принципиально важно, поскольку отражает [2] природу информационных систем.",
    blanks: [
        {
            id: 1,
            correct: "организационное и управленческое",
            options: ["организационное и управленческое", "техническое и программное", "экономическое и финансовое", "маркетинговое и рекламное"]
        },
        {
            id: 2,
            correct: "организационную и управленческую",
            options: ["организационную и управленческую", "технологическую и аппаратную", "информационную и коммуникационную", "производственную и операционную"]
        }
    ]
},
{
    text: "Предметная область характеризуется тем, что она [1], представляется множеством фрагментов, существует в [2] и во времени. Выделение предметной области — это первый шаг [3], результатом которого является модель.",
    blanks: [
        {
            id: 1,
            correct: "сложна",
            options: ["сложна", "проста", "статична", "динамична"]
        },
        {
            id: 2,
            correct: "пространстве",
            options: ["пространстве", "организации", "системе", "базе данных"]
        },
        {
            id: 3,
            correct: "абстрагирования",
            options: ["абстрагирования", "программирования", "документирования", "тестирования"]
        }
    ]
},
{
    text: "В классификации объектов предметной области выделяют [1] сущности (имеющие физическое воплощение) и [2] сущности (имена, понятия, ситуации). Объекты взаимодействуют через свои свойства, что порождает [3].",
    blanks: [
        {
            id: 1,
            correct: "материализуемые",
            options: ["материализуемые", "абстрактные", "виртуальные", "логические"]
        },
        {
            id: 2,
            correct: "нематериализуемые",
            options: ["нематериализуемые", "конкретные", "физические", "реальные"]
        },
        {
            id: 3,
            correct: "ситуации",
            options: ["ситуации", "процессы", "события", "отчеты"]
        }
    ]
},
{
    text: "Ситуации в предметной области делятся на [1] (не изменяющиеся во времени: состояния, свойства и отношения) и [2] (изменяющиеся во времени: процессы и события). Эта классификация вводит в ПрО два важных аспекта - [3] через объекты и время через статику и динамику ситуаций.",
    blanks: [
        {
            id: 1,
            correct: "статические",
            options: ["статические", "постоянные", "фиксированные", "устойчивые"]
        },
        {
            id: 2,
            correct: "динамические",
            options: ["динамические", "переменные", "временные", "изменчивые"]
        },
        {
            id: 3,
            correct: "пространство",
            options: ["пространство", "структуру", "иерархию", "организацию"]
        }
    ]
}, 
   {
    text: "Экономическая информация имеет следующие характеристики: [1] объёмы, многократное повторение циклов получения и преобразования, [2] источников и потребителей, значительный удельный вес [3] при обработке.",
    blanks: [
        {
            id: 1,
            correct: "Большие",
            options: ["Большие", "Небольшие", "Средние", "Переменные"]
        },
        {
            id: 2,
            correct: "Многообразие",
            options: ["Многообразие", "Ограниченное количество", "Единственный источник", "Стандартизированные"]
        },
        {
            id: 3,
            correct: "рутинных процедур",
            options: ["рутинных процедур", "творческих задач", "аналитических процессов", "стратегического планирования"]
        }
    ]
},
{
    text: "Внемашинное информационное обеспечение включает [1] и средства её ведения. Основные задачи: определение состава информации, выявление [2] информации, организация [3] и доступа к информации.",
    blanks: [
        {
            id: 1,
            correct: "внемашинную информационную базу",
            options: ["внемашинную информационную базу", "компьютерные сети", "программное обеспечение", "аппаратное обеспечение"]
        },
        {
            id: 2,
            correct: "логической структуры",
            options: ["логической структуры", "физического хранения", "источников финансирования", "технических требований"]
        },
        {
            id: 3,
            correct: "хранения",
            options: ["хранения", "уничтожения", "шифрования", "редактирования"]
        }
    ]
},
{
    text: "При иерархическом методе классификации строится [1] структура с отношениями подчинения, где каждый объект попадает только в [2] группировку. При фасетном методе объект может входить одновременно в [3] группировки.",
    blanks: [
        {
            id: 1,
            correct: "древовидная",
            options: ["древовидная", "матричная", "линейная", "сетевая"]
        },
        {
            id: 2,
            correct: "одну",
            options: ["одну", "две", "несколько", "все возможные"]
        },
        {
            id: 3,
            correct: "несколько",
            options: ["несколько", "только одну", "максимум две", "все"]
        }
    ]
},
{
    text: "Кодирование экономической информации включает [1] методы (отражают признаки объекта) и [2] методы (присваивают уникальные номера). Структура кода может включать классификационную часть (раскрывает признаки) и [3] часть (обеспечивает уникальность).",
    blanks: [
        {
            id: 1,
            correct: "классификационные",
            options: ["классификационные", "статистические", "аналитические", "графические"]
        },
        {
            id: 2,
            correct: "регистрационные",
            options: ["регистрационные", "описательные", "символические", "логические"]
        },
        {
            id: 3,
            correct: "идентификационную",
            options: ["идентификационную", "описательную", "техническую", "финансовую"]
        }
    ]
    },
    {
    text: "Информационная система предприятия — это совокупность взаимосвязанных подсистем, которые обслуживают различные уровни управления: [1] уровень (TPS), уровень знания (KWS, OAS), [2] уровень (MIS, DSS) и стратегический уровень (ESS).",
    blanks: [
        {
            id: 1,
            correct: "производственный",
            options: ["производственный", "технический", "оперативный", "административный"]
        },
        {
            id: 2,
            correct: "уровень управления",
            options: ["уровень управления", "уровень данных", "исполнительный уровень", "тактический уровень"]
        }
    ]
},
{
    text: "Стандарт [1] — это интеграционная программная структура, объединяющая различного рода приложения, разработанные независимо друг от друга. Для интеграции используются два архитектурных подхода: интеграция по типу [2] и интеграция [3].",
    blanks: [
        {
            id: 1,
            correct: "EAI (Enterprise application integration)",
            options: ["EAI (Enterprise application integration)", "ESB (Enterprise Service Bus)", "SOA (Service-Oriented Architecture)", "ERP (Enterprise Resource Planning)"]
        },
        {
            id: 2,
            correct: "точка-точка",
            options: ["точка-точка", "звезда", "кольцо", "шина"]
        },
        {
            id: 3,
            correct: "по шине сервисов",
            options: ["по шине сервисов", "по иерархии", "по матрице", "по сети"]
        }
    ]
},
{
    text: "Модель предметной области строится на трех уровнях абстракции: на [1] уровне (определение требований), на [2] уровне (спецификация требований) и на [3] уровне (реализация требований).",
    blanks: [
        {
            id: 1,
            correct: "внешнем",
            options: ["внешнем", "техническом", "физическом", "операционном"]
        },
        {
            id: 2,
            correct: "концептуальном",
            options: ["концептуальном", "практическом", "логическом", "детальном"]
        },
        {
            id: 3,
            correct: "внутреннем",
            options: ["внутреннем", "глобальном", "локальном", "системном"]
        }
    ]
},
{
    text: "В нотации EPC ключевыми элементами являются: [1] (мгновенное состояние, активизирующее функции), [2] (элемент работы, минимальный логический этап процесса) и логические операторы, управляющие [3] потока.",
    blanks: [
        {
            id: 1,
            correct: "Событие",
            options: ["Событие", "Объект", "Атрибут", "Сущность"]
        },
        {
            id: 2,
            correct: "Функция",
            options: ["Функция", "Процесс", "Операция", "Действие"]
        },
        {
            id: 3,
            correct: "ветвлением и слиянием",
            options: ["ветвлением и слиянием", "хранением и обработкой", "вводом и выводом", "созданием и удалением"]
        }
    ]
},
{
    text: "ER-модель включает базовые элементы: [1] (реальный или абстрактный объект), [2] (свойство, характеризующее сущность) и [3] (ассоциация между сущностями). Связи характеризуются степенью: один к одному, один ко многим, многие ко многим.",
    blanks: [
        {
            id: 1,
            correct: "Сущность",
            options: ["Сущность", "Класс", "Тип", "Экземпляр"]
        },
        {
            id: 2,
            correct: "Атрибут",
            options: ["Атрибут", "Метод", "Поле", "Параметр"]
        },
        {
            id: 3,
            correct: "Связь",
            options: ["Связь", "Отношение", "Зависимость", "Ассоциация"]
        }
    ]
}

];

// Функция для обновления счетчиков
function updateNavigationCounters() {
    // Объект с соответствием режимов и массивов
    const dataMap = {
        'test': questionsData,
        'cards': cardsData,
        'match': matchingData,
        'fill': fillInData
    };
    
    // Находим все элементы навигации
    const navItems = document.querySelectorAll('.mobile-nav-item');
    
    navItems.forEach(item => {
        const mode = item.getAttribute('data-mode');
        const badge = item.querySelector('.mobile-nav-badge');
        
        if (badge && dataMap[mode]) {
            // Устанавливаем количество элементов
            badge.textContent = dataMap[mode].length;
        }
    });
}


// Глобальные переменные
let currentQuestionIndex = 0;
let correctAnswers = 0;
let wrongAnswers = 0;
let currentCardIndex = 0;
let knownCards = new Set();
let selectedTerm = null;
let selectedDefinition = null;
let matchedPairs = 0;
let currentFillIndex = 0;
let correctFills = 0;
let studyTime = 0;
let studyTimer = null;

// Выбираем случайные 10 элементов для каждого режима
let shuffledQuestions = getRandomSubset(questionsData, 10);
let randomCards = getRandomSubset(cardsData, 10);
let randomMatchingData = getRandomSubset(matchingData, 5);
let randomFillData = getRandomSubset(fillInData, 10);

// DOM элементы
const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
const mobileMenuOverlay = document.getElementById('mobile-menu-overlay');
const mobileMenu = document.getElementById('mobile-menu');
const mobileMenuClose = document.querySelector('.mobile-menu-close');
const mobileModeSelect = document.getElementById('mobile-mode-select');
const mobileNavItems = document.querySelectorAll('.mobile-nav-item');
const navItems = document.querySelectorAll('.nav-item');

// Элементы тестового режима
const questionText = document.getElementById('question-text');
const answerOptions = document.querySelectorAll('.answer-option');
const answerLabels = [
    document.getElementById('label1'),
    document.getElementById('label2'),
    document.getElementById('label3'),
    document.getElementById('label4')
];
const answerInputs = document.querySelectorAll('.answer-input');
const checkBtn = document.getElementById('check-btn');
const nextBtn = document.getElementById('next-btn');
const hintBtn = document.getElementById('hint-btn');
const shuffleBtn = document.getElementById('shuffle-btn');
const resetBtn = document.getElementById('reset-btn');
const resultArea = document.getElementById('result-area');
const resultIcon = document.getElementById('result-icon');
const resultTitle = document.getElementById('result-title');
const resultText = document.getElementById('result-text');
const currentQuestionSpan = document.getElementById('current-question');
const totalQuestionsSpan = document.getElementById('total-questions');
const questionNumberSpan = document.getElementById('question-number');
const correctCountSpan = document.getElementById('correct-count');
const wrongCountSpan = document.getElementById('wrong-count');
const accuracySpan = document.getElementById('accuracy');
const progressFill = document.getElementById('progress-fill');

// Элементы карточек
const flashCard = document.getElementById('flash-card');
const cardTerm = document.getElementById('card-term');
const cardDefinition = document.getElementById('card-definition');
const prevCardBtn = document.getElementById('prev-card');
const nextCardBtn = document.getElementById('next-card');
const shuffleCardsBtn = document.getElementById('shuffle-cards');
const cardCounter = document.getElementById('card-counter');
const cardCounterBack = document.getElementById('card-counter-back');
const markKnownBtn = document.getElementById('mark-known');
const markRepeatBtn = document.getElementById('mark-repeat');
const knownCountSpan = document.getElementById('known-count');
const totalCardsSpan = document.getElementById('total-cards');

// Элементы сопоставления
const termsList = document.getElementById('terms-list');
const definitionsList = document.getElementById('definitions-list');
const matchedCountSpan = document.getElementById('matched-count');
const totalMatchesSpan = document.getElementById('total-matches');
const resetMatchBtn = document.getElementById('reset-match');
const matchFeedback = document.getElementById('match-feedback');

// Элементы заполнения пропусков
const fillText = document.getElementById('fill-text');
const fillOptions = document.getElementById('fill-options');
const fillNumberSpan = document.getElementById('fill-number');
const checkFillBtn = document.getElementById('check-fill');
const nextFillBtn = document.getElementById('next-fill');
const hintFillBtn = document.getElementById('hint-fill');
const clearFillBtn = document.getElementById('clear-fill');
const selectedAnswersDiv = document.getElementById('selected-answers');
const filledCountSpan = document.getElementById('filled-count');
const totalFillSpan = document.getElementById('total-fill');
const fillFeedback = document.getElementById('fill-feedback');
const studyTimeSpan = document.getElementById('study-time');

// Вспомогательные функции
function getRandomSubset(array, count) {
    if (array.length <= count) return [...array];
    
    const shuffled = [...array].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
}

// Функция для обновления количества элементов в навигации
function updateNavCounts() {
    const testBadge = document.querySelector('.mobile-nav-item[data-mode="test"] .mobile-nav-badge');
    const cardsBadge = document.querySelector('.mobile-nav-item[data-mode="cards"] .mobile-nav-badge');
    const matchBadge = document.querySelector('.mobile-nav-item[data-mode="match"] .mobile-nav-badge');
    const fillBadge = document.querySelector('.mobile-nav-item[data-mode="fill"] .mobile-nav-badge');
    
    if (testBadge) testBadge.textContent = questionsData.length;
    if (cardsBadge) cardsBadge.textContent = cardsData.length;
    if (matchBadge) matchBadge.textContent = matchingData.length;
    if (fillBadge) fillBadge.textContent = fillInData.length;
}

// Инициализация приложения
document.addEventListener('DOMContentLoaded', function() {
    // Установка общего количества
    totalQuestionsSpan.textContent = shuffledQuestions.length;
    questionNumberSpan.textContent = 1;
    totalCardsSpan.textContent = randomCards.length;
    totalMatchesSpan.textContent = randomMatchingData.length;
    totalFillSpan.textContent = randomFillData.length;
    
    // Запуск таймера обучения
    startStudyTimer();
    updateNavigationCounters();
    
    // Загрузка сохраненного прогресса
    loadProgress();
    
    // Инициализация режимов
    initTestMode();
    initCardsMode();
    initMatchingMode();
    initFillMode();
    
    // Навигация между режимами
    setupNavigation();
    
    // Мобильное меню
    setupMobileMenu();
    
    // Обработчики для тестового режима
    checkBtn.addEventListener('click', checkAnswer);
    nextBtn.addEventListener('click', nextQuestion);
    hintBtn.addEventListener('click', showHint);
    shuffleBtn.addEventListener('click', shuffleQuestions);
    resetBtn.addEventListener('click', resetTest);
    
    // Обработчики кликов по вариантам ответов
    answerOptions.forEach(option => {
        option.addEventListener('click', function() {
            const index = parseInt(this.dataset.index);
            selectAnswer(index);
        });
    });
    
    // Обработчики для карточек
    flashCard.addEventListener('click', flipCard);
    prevCardBtn.addEventListener('click', showPrevCard);
    nextCardBtn.addEventListener('click', showNextCard);
    shuffleCardsBtn.addEventListener('click', shuffleCards);
    markKnownBtn.addEventListener('click', markCardAsKnown);
    markRepeatBtn.addEventListener('click', markCardForRepeat);
    
    // Обработчик для сброса сопоставления
    resetMatchBtn.addEventListener('click', resetMatchingGame);
    
    // Обработчики для заполнения пропусков
    checkFillBtn.addEventListener('click', checkFillAnswer);
    nextFillBtn.addEventListener('click', nextFillQuestion);
    hintFillBtn.addEventListener('click', showFillHint);
    clearFillBtn.addEventListener('click', clearFillSelections);
    
    // Сохранение прогресса при закрытии
    window.addEventListener('beforeunload', saveProgress);
});

// ===== ОБЩИЕ ФУНКЦИИ =====

function setupNavigation() {
    // Десктопная навигация
    navItems.forEach(item => {
        item.addEventListener('click', function(e) {
            e.preventDefault();
            const mode = this.getAttribute('data-mode');
            switchMode(mode);
            
            // Обновить активный элемент
            navItems.forEach(nav => nav.classList.remove('active'));
            this.classList.add('active');
            
            // Закрыть мобильное меню если открыто
            closeMobileMenu();
        });
    });
    
    // Мобильная навигация
    mobileNavItems.forEach(item => {
        item.addEventListener('click', function(e) {
            e.preventDefault();
            const mode = this.getAttribute('data-mode');
            switchMode(mode);
            
            // Обновить активный элемент
            mobileNavItems.forEach(nav => nav.classList.remove('active'));
            this.classList.add('active');
            
            // Закрыть мобильное меню
            closeMobileMenu();
        });
    });
    
    // Выбор режима через select
    if (mobileModeSelect) {
        mobileModeSelect.addEventListener('change', function() {
            switchMode(this.value);
        });
    }
}

function switchMode(mode) {
    // Скрыть все режимы
    document.querySelectorAll('.mode-content').forEach(content => {
        content.classList.remove('active');
    });
    
    // Показать выбранный режим
    const modeElement = document.getElementById(`${mode}-mode`);
    if (modeElement) {
        modeElement.classList.add('active');
    }
    
    // Обновить активные элементы навигации
    updateActiveNav(mode);
    
    // Обновить select
    if (mobileModeSelect) {
        mobileModeSelect.value = mode;
    }
    
    // Сохранить текущий режим
    saveProgress();
}

function updateActiveNav(mode) {
    // Десктоп
    navItems.forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('data-mode') === mode) {
            item.classList.add('active');
        }
    });
    
    // Мобильное
    mobileNavItems.forEach(item => {
        item.classList.remove('active');
        if (item.getAttribute('data-mode') === mode) {
            item.classList.add('active');
        }
    });
}

function setupMobileMenu() {
    if (mobileMenuBtn) {
        mobileMenuBtn.addEventListener('click', openMobileMenu);
    }
    if (mobileMenuOverlay) {
        mobileMenuOverlay.addEventListener('click', closeMobileMenu);
    }
    if (mobileMenuClose) {
        mobileMenuClose.addEventListener('click', closeMobileMenu);
    }
}

function openMobileMenu() {
    if (mobileMenu && mobileMenuOverlay) {
        mobileMenu.classList.add('show');
        mobileMenuOverlay.style.display = 'block';
        setTimeout(() => {
            mobileMenuOverlay.style.opacity = '1';
        }, 10);
    }
}

function closeMobileMenu() {
    if (mobileMenu && mobileMenuOverlay) {
        mobileMenu.classList.remove('show');
        mobileMenuOverlay.style.opacity = '0';
        setTimeout(() => {
            mobileMenuOverlay.style.display = 'none';
        }, 300);
    }
}

function startStudyTimer() {
    studyTimer = setInterval(() => {
        studyTime++;
        updateStudyTimeDisplay();
    }, 1000);
}

function updateStudyTimeDisplay() {
    if (!studyTimeSpan) return;
    
    const hours = Math.floor(studyTime / 3600);
    const minutes = Math.floor((studyTime % 3600) / 60);
    const seconds = studyTime % 60;
    
    if (hours > 0) {
        studyTimeSpan.textContent = `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    } else {
        studyTimeSpan.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
}

function saveProgress() {
    const progress = {
        knownCards: Array.from(knownCards),
        correctAnswers,
        wrongAnswers,
        studyTime,
        currentQuestionIndex,
        currentCardIndex,
        currentFillIndex,
        correctFills,
        matchedPairs,
        lastMode: document.querySelector('.mode-content.active')?.id.replace('-mode', '') || 'test',
        shuffledQuestions: shuffledQuestions.map(q => questionsData.indexOf(q)),
        randomCards: randomCards.map(c => cardsData.indexOf(c)),
        randomMatchingData: randomMatchingData.map(m => matchingData.indexOf(m)),
        randomFillData: randomFillData.map(f => fillInData.indexOf(f))
    };
    
    localStorage.setItem('isProProgress', JSON.stringify(progress));
}

function loadProgress() {
    const savedProgress = localStorage.getItem('isProProgress');
    if (savedProgress) {
        try {
            const progress = JSON.parse(savedProgress);
            
            knownCards = new Set(progress.knownCards || []);
            correctAnswers = progress.correctAnswers || 0;
            wrongAnswers = progress.wrongAnswers || 0;
            studyTime = progress.studyTime || 0;
            currentQuestionIndex = progress.currentQuestionIndex || 0;
            currentCardIndex = progress.currentCardIndex || 0;
            currentFillIndex = progress.currentFillIndex || 0;
            correctFills = progress.correctFills || 0;
            matchedPairs = progress.matchedPairs || 0;
            
            // Восстанавливаем случайные подмножества
            if (progress.shuffledQuestions) {
                shuffledQuestions = progress.shuffledQuestions
                    .map(i => questionsData[i])
                    .filter(q => q !== undefined);
            }
            
            if (progress.randomCards) {
                randomCards = progress.randomCards
                    .map(i => cardsData[i])
                    .filter(c => c !== undefined);
            }
            
            if (progress.randomMatchingData) {
                randomMatchingData = progress.randomMatchingData
                    .map(i => matchingData[i])
                    .filter(m => m !== undefined);
            }
            
            if (progress.randomFillData) {
                randomFillData = progress.randomFillData
                    .map(i => fillInData[i])
                    .filter(f => f !== undefined);
            }
            
            // Обновляем отображение
            updateTestStats();
            updateStudyTimeDisplay();
            
            // Переключаемся на последний режим
            if (progress.lastMode) {
                setTimeout(() => switchMode(progress.lastMode), 100);
            }
        } catch (e) {
            console.error('Ошибка при загрузке прогресса:', e);
        }
    }
}

// ===== ТЕСТОВЫЙ РЕЖИМ =====

function initTestMode() {
    if (shuffledQuestions.length === 0) {
        shuffledQuestions = getRandomSubset(questionsData, 10);
    }
    loadQuestion(currentQuestionIndex);
    updateTestStats();
}

function loadQuestion(index) {
    if (index >= shuffledQuestions.length || shuffledQuestions.length === 0) {
        // Все вопросы пройдены
        if (questionText) {
            questionText.textContent = "🎉 Поздравляем! Вы прошли все вопросы!";
        }
        answerOptions.forEach((option, i) => {
            if (option) option.style.display = 'none';
        });
        if (checkBtn) checkBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = true;
        return;
    }
    
    const question = shuffledQuestions[index];
    if (questionText) {
        questionText.textContent = question.question;
    }
    if (questionNumberSpan) {
        questionNumberSpan.textContent = index + 1;
    }
    
    for (let i = 0; i < 4; i++) {
        if (answerLabels[i]) {
            answerLabels[i].textContent = question.answers[i];
            if (answerOptions[i]) {
                answerOptions[i].style.display = 'flex';
                answerOptions[i].classList.remove('selected', 'correct', 'incorrect');
            }
            if (answerInputs[i]) {
                answerInputs[i].checked = false;
            }
        }
    }
    
    if (currentQuestionSpan) {
        currentQuestionSpan.textContent = index + 1;
    }
    
    // Скрыть результат
    if (resultArea) {
        resultArea.classList.remove('show');
    }
    
    // Обновить прогресс-бар
    const progressPercent = ((index + 1) / shuffledQuestions.length) * 100;
    if (progressFill) {
        progressFill.style.width = `${progressPercent}%`;
    }
    
    // Включить все варианты
    answerOptions.forEach(option => {
        if (option) {
            option.style.pointerEvents = 'auto';
        }
    });
    
    if (checkBtn) checkBtn.disabled = false;
    if (nextBtn) nextBtn.disabled = true;
    
    // Сохранить прогресс
    saveProgress();
}

function selectAnswer(index) {
    // Снять выделение со всех вариантов
    answerOptions.forEach(option => {
        if (option) {
            option.classList.remove('selected');
        }
    });
    
    // Выделить выбранный вариант
    if (answerOptions[index]) {
        answerOptions[index].classList.add('selected');
        if (answerInputs[index]) {
            answerInputs[index].checked = true;
        }
    }
    
    // Включить кнопку проверки
    if (checkBtn) checkBtn.disabled = false;
}

function checkAnswer() {
    const selectedOption = document.querySelector('.answer-option.selected');
    
    if (!selectedOption) {
        showNotification('Выберите ответ!', 'warning');
        return;
    }
    
    const answerIndex = parseInt(selectedOption.dataset.index);
    const question = shuffledQuestions[currentQuestionIndex];
    
    // Отключить все варианты
    answerOptions.forEach(option => {
        if (option) {
            option.style.pointerEvents = 'none';
        }
    });
    
    // Подсветить правильный и неправильный ответы
    answerOptions.forEach((option, index) => {
        if (!option) return;
        
        if (index === question.correct) {
            option.classList.add('correct');
            if (index === answerIndex) {
                option.classList.add('selected');
            }
        } else if (index === answerIndex) {
            option.classList.add('incorrect');
        }
    });
    
    // Показать результат
    if (resultArea) {
        resultArea.classList.add('show');
        
        if (answerIndex === question.correct) {
            if (resultIcon) resultIcon.className = 'fas fa-check-circle success';
            if (resultTitle) resultTitle.textContent = 'Правильно!';
            if (resultText) resultText.textContent = question.explanation;
            resultArea.style.backgroundColor = 'rgba(76, 201, 240, 0.1)';
            correctAnswers++;
            
            // Анимация успеха
            selectedOption.classList.add('pulse');
        } else {
            if (resultIcon) resultIcon.className = 'fas fa-times-circle error';
            if (resultTitle) resultTitle.textContent = 'Неправильно';
            if (resultText) resultText.textContent = `Правильный ответ: "${question.answers[question.correct]}". ${question.explanation}`;
            resultArea.style.backgroundColor = 'rgba(249, 65, 68, 0.1)';
            wrongAnswers++;
            
            // Анимация ошибки
            selectedOption.classList.add('shake');
        }
    }
    
    if (checkBtn) checkBtn.disabled = true;
    if (nextBtn) nextBtn.disabled = false;
    
    updateTestStats();
    saveProgress();
}

function nextQuestion() {
    currentQuestionIndex++;
    
    if (currentQuestionIndex >= shuffledQuestions.length) {
        currentQuestionIndex = 0;
    }
    
    loadQuestion(currentQuestionIndex);
    if (nextBtn) nextBtn.disabled = true;
}

function shuffleQuestions() {
    // Перемешать вопросы алгоритмом Фишера-Йейтса
    for (let i = shuffledQuestions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffledQuestions[i], shuffledQuestions[j]] = [shuffledQuestions[j], shuffledQuestions[i]];
    }
    
    // Сбросить на первый вопрос
    currentQuestionIndex = 0;
    loadQuestion(currentQuestionIndex);
    
    showNotification('Вопросы перемешаны! Теперь они идут в случайном порядке.', 'success');
}

function resetTest() {
    // Сбросить статистику
    correctAnswers = 0;
    wrongAnswers = 0;
    currentQuestionIndex = 0;
    
    // Выбрать новые случайные 10 вопросов
    shuffledQuestions = getRandomSubset(questionsData, 10);
    
    initTestMode();
    showNotification('Тест начат заново. Выбраны новые случайные вопросы.', 'info');
}

function showHint() {
    const question = shuffledQuestions[currentQuestionIndex];
    
    // Найдем индексы неправильных ответов
    const wrongAnswersIndices = [0, 1, 2, 3].filter(index => index !== question.correct);
    
    if (wrongAnswersIndices.length < 2) return;
    
    // Случайно выберем два неправильных ответа для скрытия
    const indicesToHide = [];
    while (indicesToHide.length < 2 && indicesToHide.length < wrongAnswersIndices.length) {
        const randomIndex = wrongAnswersIndices[Math.floor(Math.random() * wrongAnswersIndices.length)];
        if (!indicesToHide.includes(randomIndex)) {
            indicesToHide.push(randomIndex);
        }
    }
    
    // Временно скроем эти варианты
    indicesToHide.forEach(index => {
        const option = answerOptions[index];
        const label = answerLabels[index];
        if (option && label) {
            const originalText = label.textContent;
            
            label.textContent = '[Скрыто]';
            label.style.opacity = '0.5';
            option.style.pointerEvents = 'none';
            
            // Восстановим через 5 секунд
            setTimeout(() => {
                label.textContent = originalText;
                label.style.opacity = '1';
                if (option) {
                    option.style.pointerEvents = 'auto';
                }
            }, 5000);
        }
    });
    
    showNotification('Подсказка: скрыты 2 неправильных варианта', 'info');
}

function updateTestStats() {
    if (correctCountSpan) correctCountSpan.textContent = correctAnswers;
    if (wrongCountSpan) wrongCountSpan.textContent = wrongAnswers;
    
    const total = correctAnswers + wrongAnswers;
    const accuracy = total > 0 ? Math.round((correctAnswers / total) * 100) : 0;
    if (accuracySpan) accuracySpan.textContent = `${accuracy}%`;
}

// ===== РЕЖИМ КАРТОЧЕК =====

function initCardsMode() {
    loadCard(currentCardIndex);
}

function loadCard(index) {
    if (index >= randomCards.length) {
        if (cardTerm) cardTerm.textContent = "Карточки закончились!";
        if (cardDefinition) cardDefinition.textContent = "Начните заново или перемешайте карточки.";
        return;
    }
    
    const card = randomCards[index];
    if (cardTerm) cardTerm.textContent = card.term;
    if (cardDefinition) cardDefinition.textContent = card.definition;
    
    if (cardCounter) cardCounter.textContent = `${index + 1}/${randomCards.length}`;
    if (cardCounterBack) cardCounterBack.textContent = `${index + 1}/${randomCards.length}`;
    
    // Сброс поворота карточки
    if (flashCard) flashCard.classList.remove('flipped');
    
    // Проверка, изучена ли карточка
    if (markKnownBtn) {
        if (knownCards.has(index)) {
            markKnownBtn.disabled = true;
            markKnownBtn.innerHTML = '<i class="fas fa-check-double"></i> Изучено';
            markKnownBtn.classList.add('btn-secondary');
            markKnownBtn.classList.remove('btn-success');
            if (flashCard) {
                flashCard.style.boxShadow = '0 10px 20px rgba(76, 201, 240, 0.3)';
            }
        } else {
            markKnownBtn.disabled = false;
            markKnownBtn.innerHTML = '<i class="fas fa-check"></i> Отметить как изученное';
            markKnownBtn.classList.add('btn-success');
            markKnownBtn.classList.remove('btn-secondary');
            if (flashCard) {
                flashCard.style.boxShadow = '0 10px 20px rgba(0,0,0,0.1)';
            }
        }
    }
    
    if (knownCountSpan) knownCountSpan.textContent = knownCards.size;
    
    // Анимация
    if (flashCard) {
        flashCard.classList.add('animate__animated', 'animate__flipInY');
        setTimeout(() => {
            flashCard.classList.remove('animate__animated', 'animate__flipInY');
        }, 500);
    }
}

function flipCard() {
    this.classList.toggle('flipped');
    
    // Анимация
    this.classList.add('animate__animated', 'animate__flipInY');
    setTimeout(() => {
        this.classList.remove('animate__animated', 'animate__flipInY');
    }, 500);
}

function showPrevCard() {
    currentCardIndex--;
    if (currentCardIndex < 0) {
        currentCardIndex = randomCards.length - 1;
    }
    loadCard(currentCardIndex);
    saveProgress();
}

function showNextCard() {
    currentCardIndex++;
    if (currentCardIndex >= randomCards.length) {
        currentCardIndex = 0;
    }
    loadCard(currentCardIndex);
    saveProgress();
}

function shuffleCards() {
    // Перемешиваем массив карточек алгоритмом Фишера-Йейтса
    for (let i = randomCards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [randomCards[i], randomCards[j]] = [randomCards[j], randomCards[i]];
    }
    
    // Находим индекс текущего термина в перемешанном массиве
    const currentTerm = cardTerm ? cardTerm.textContent : '';
    const newIndex = randomCards.findIndex(card => card.term === currentTerm);
    currentCardIndex = newIndex !== -1 ? newIndex : 0;
    
    loadCard(currentCardIndex);
    showNotification('Карточки перемешаны!', 'success');
    saveProgress();
}

function markCardAsKnown() {
    knownCards.add(currentCardIndex);
    loadCard(currentCardIndex);
    showNotification('Карточка отмечена как изученная', 'success');
    saveProgress();
}

function markCardForRepeat() {
    knownCards.delete(currentCardIndex);
    loadCard(currentCardIndex);
    showNotification('Карточка добавлена в список повторения', 'info');
    saveProgress();
}

// ===== РЕЖИМ СОПОСТАВЛЕНИЯ =====

function initMatchingMode() {
    resetMatchingGame();
}

function resetMatchingGame() {
    // Очищаем списки
    if (termsList) termsList.innerHTML = '';
    if (definitionsList) definitionsList.innerHTML = '';
    
    // Перемешиваем данные для игры
    const shuffledTerms = [...randomMatchingData].sort(() => Math.random() - 0.5);
    const shuffledDefinitions = [...randomMatchingData].sort(() => Math.random() - 0.5);
    
    // Сбрасываем состояние
    selectedTerm = null;
    selectedDefinition = null;
    matchedPairs = 0;
    
    // Заполняем колонку терминов
    shuffledTerms.forEach((item, index) => {
        if (termsList) {
            const termElement = document.createElement('div');
            termElement.className = 'match-item';
            termElement.textContent = item.term;
            termElement.dataset.id = index;
            termElement.dataset.term = item.term;
            termElement.dataset.definition = item.definition;
            termElement.addEventListener('click', () => selectTerm(termElement));
            termsList.appendChild(termElement);
        }
    });
    
    // Заполняем колонку определений
    shuffledDefinitions.forEach((item, index) => {
        if (definitionsList) {
            const definitionElement = document.createElement('div');
            definitionElement.className = 'match-item';
            definitionElement.textContent = item.definition;
            definitionElement.dataset.id = index;
            definitionElement.dataset.term = item.term;
            definitionElement.dataset.definition = item.definition;
            definitionElement.addEventListener('click', () => selectDefinition(definitionElement));
            definitionsList.appendChild(definitionElement);
        }
    });
    
    // Обновляем статистику
    if (matchedCountSpan) matchedCountSpan.textContent = matchedPairs;
    if (totalMatchesSpan) totalMatchesSpan.textContent = randomMatchingData.length;
    
    // Очищаем обратную связь
    if (matchFeedback) {
        matchFeedback.innerHTML = '<p>Выберите термин в левой колонке и соответствующее определение в правой.</p>';
        matchFeedback.style.backgroundColor = '#f8f9fa';
    }
}

function selectTerm(element) {
    // Если элемент уже сопоставлен, игнорируем
    if (element.classList.contains('matched')) return;
    
    // Снимаем выделение с предыдущего выбора
    document.querySelectorAll('.match-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Выделяем выбранный элемент
    element.classList.add('selected');
    selectedTerm = element;
    
    // Проверяем, есть ли уже выбранное определение
    if (selectedDefinition) {
        checkMatch();
    }
}

function selectDefinition(element) {
    // Если элемент уже сопоставлен, игнорируем
    if (element.classList.contains('matched')) return;
    
    // Снимаем выделение с предыдущего выбора
    document.querySelectorAll('.match-item.selected').forEach(item => {
        item.classList.remove('selected');
    });
    
    // Выделяем выбранный элемент
    element.classList.add('selected');
    selectedDefinition = element;
    
    // Проверяем, есть ли уже выбранный термин
    if (selectedTerm) {
        checkMatch();
    }
}

function checkMatch() {
    if (!selectedTerm || !selectedDefinition) return;
    
    // Проверяем, соответствует ли выбранная пара
    const term = selectedTerm.dataset.term;
    const definition = selectedDefinition.dataset.definition;
    
    if (term === selectedDefinition.dataset.term && definition === selectedTerm.dataset.definition) {
        // Правильное сопоставление
        selectedTerm.classList.add('matched');
        selectedTerm.classList.remove('selected');
        selectedDefinition.classList.add('matched');
        selectedDefinition.classList.remove('selected');
        
        matchedPairs++;
        if (matchedCountSpan) matchedCountSpan.textContent = matchedPairs;
        
        // Показываем позитивную обратную связь
        if (matchFeedback) {
            matchFeedback.innerHTML = `
                <div style="text-align: center;">
                    <i class="fas fa-check-circle" style="font-size: 2rem; color: #4cc9f0; margin-bottom: 10px;"></i>
                    <p style="font-weight: bold; color: #4cc9f0;">Правильно! "${term}" соответствует выбранному определению</p>
                </div>
            `;
            matchFeedback.style.backgroundColor = 'rgba(76, 201, 240, 0.1)';
        }
        
        // Проверяем, завершена ли игра
        if (matchedPairs === randomMatchingData.length && matchFeedback) {
            setTimeout(() => {
                matchFeedback.innerHTML = `
                    <div style="text-align: center;">
                        <i class="fas fa-trophy" style="font-size: 2rem; color: #f8961e; margin-bottom: 10px;"></i>
                        <p style="font-weight: bold;">Поздравляем! Вы успешно сопоставили все термины и определения!</p>
                        <button class="btn btn-primary" onclick="resetMatchingGame()" style="margin-top: 15px;">
                            <i class="fas fa-redo"></i> Играть снова
                        </button>
                    </div>
                `;
                matchFeedback.style.backgroundColor = 'rgba(248, 150, 30, 0.1)';
            }, 1000);
        }
    } else {
        // Неправильное сопоставление
        if (matchFeedback) {
            matchFeedback.innerHTML = `
                <div style="text-align: center;">
                    <i class="fas fa-times-circle" style="font-size: 2rem; color: #f94144; margin-bottom: 10px;"></i>
                    <p style="font-weight: bold; color: #f94144;">Неправильно! Попробуйте еще раз.</p>
                </div>
            `;
            matchFeedback.style.backgroundColor = 'rgba(249, 65, 68, 0.1)';
        }
        
        // Снимаем выделение через секунду
        setTimeout(() => {
            if (selectedTerm) selectedTerm.classList.remove('selected');
            if (selectedDefinition) selectedDefinition.classList.remove('selected');
            selectedTerm = null;
            selectedDefinition = null;
        }, 1000);
    }
    
    // Сбрасываем выбранные элементы
    setTimeout(() => {
        if (selectedTerm && selectedTerm.classList.contains('selected')) {
            selectedTerm.classList.remove('selected');
        }
        if (selectedDefinition && selectedDefinition.classList.contains('selected')) {
            selectedDefinition.classList.remove('selected');
        }
        selectedTerm = null;
        selectedDefinition = null;
    }, 1500);
}

// ===== РЕЖИМ ЗАПОЛНЕНИЯ ПРОПУСКОВ =====

function initFillMode() {
    loadFillQuestion(currentFillIndex);
}

function loadFillQuestion(index) {
    if (index >= randomFillData.length) {
        if (fillText) {
            fillText.textContent = "Вы заполнили все пропуски! Начните заново или перейдите в другой режим.";
        }
        if (fillOptions) fillOptions.innerHTML = '';
        if (checkFillBtn) checkFillBtn.disabled = true;
        if (nextFillBtn) nextFillBtn.disabled = true;
        return;
    }
    
    const fillItem = randomFillData[index];
    
    // Формируем текст с пропусками
    if (fillText) {
        let displayText = fillItem.text;
        fillItem.blanks.forEach(blank => {
            displayText = displayText.replace(`[${blank.id}]`, `<span class="blank" data-id="${blank.id}">_____</span>`);
        });
        
        fillText.innerHTML = displayText;
    }
    
    if (fillNumberSpan) {
        fillNumberSpan.textContent = index + 1;
    }
    
    // Заполняем варианты ответов
    if (fillOptions) {
        fillOptions.innerHTML = '';
        
        // Собираем все варианты из всех пропусков
        const allOptions = [];
        fillItem.blanks.forEach(blank => {
            blank.options.forEach(option => {
                if (!allOptions.includes(option)) {
                    allOptions.push(option);
                }
            });
        });
        
        // Перемешиваем варианты
        const shuffledOptions = [...allOptions].sort(() => Math.random() - 0.5);
        
        // Создаем элементы вариантов
        shuffledOptions.forEach(option => {
            const optionElement = document.createElement('div');
            optionElement.className = 'fill-option';
            optionElement.textContent = option;
            optionElement.addEventListener('click', () => selectFillOption(optionElement, option));
            fillOptions.appendChild(optionElement);
        });
    }
    
    // Сбрасываем состояние
    if (selectedAnswersDiv) selectedAnswersDiv.innerHTML = '';
    selectedBlanks = {};
    
    if (fillFeedback) {
        fillFeedback.innerHTML = '<p>Выберите правильный вариант для каждого пропуска в тексте.</p>';
        fillFeedback.style.backgroundColor = '#f8f9fa';
    }
    
    if (checkFillBtn) checkFillBtn.disabled = false;
    if (nextFillBtn) nextFillBtn.disabled = true;
    
    // Обновляем статистику
    if (filledCountSpan) filledCountSpan.textContent = correctFills;
    if (totalFillSpan) totalFillSpan.textContent = randomFillData.length;
}

let selectedBlanks = {};

function selectFillOption(element, option) {
    // Если вариант уже использован, игнорируем
    if (element.classList.contains('used')) return;
    
    // Снимаем выделение с предыдущих выбранных вариантов
    document.querySelectorAll('.fill-option.selected').forEach(item => {
        if (!item.classList.contains('used')) {
            item.classList.remove('selected');
        }
    });
    
    // Выделяем выбранный вариант
    element.classList.add('selected');
    
    // Находим первый незаполненный пропуск
    const blanks = document.querySelectorAll('.blank');
    let blankToFill = null;
    
    for (const blank of blanks) {
        if (blank.textContent === '_____') {
            blankToFill = blank;
            break;
        }
    }
    
    if (blankToFill) {
        // Сохраняем выбранный вариант для этого пропуска
        const blankId = blankToFill.dataset.id;
        selectedBlanks[blankId] = option;
        
        // Заполняем пропуск
        blankToFill.textContent = option;
        blankToFill.style.color = '#4361ee';
        blankToFill.style.fontWeight = 'bold';
        
        // Добавляем в список выбранных ответов
        if (selectedAnswersDiv) {
            const selectedAnswer = document.createElement('div');
            selectedAnswer.className = 'selected-answer';
            selectedAnswer.innerHTML = `
                <span>Пропуск ${blankId}: ${option}</span>
                <i class="fas fa-times" onclick="removeFillSelection(${blankId}, '${option.replace(/'/g, "\\'")}')"></i>
            `;
            selectedAnswersDiv.appendChild(selectedAnswer);
        }
        
        // Помечаем вариант как использованный
        element.classList.remove('selected');
        element.classList.add('used');
        element.style.cursor = 'default';
        
        // Проверяем, все ли пропуски заполнены
        const allFilled = Array.from(blanks).every(blank => blank.textContent !== '_____');
        
        if (allFilled && checkFillBtn) {
            checkFillBtn.disabled = false;
        }
    }
}

function removeFillSelection(blankId, option) {
    // Удаляем из выбранных
    delete selectedBlanks[blankId];
    
    // Восстанавливаем пропуск
    const blankElement = document.querySelector(`.blank[data-id="${blankId}"]`);
    if (blankElement) {
        blankElement.textContent = '_____';
        blankElement.style.color = '';
        blankElement.style.fontWeight = '';
        blankElement.innerHTML = '_____';
    }
    
    // Восстанавливаем вариант ответа
    const fillOptionsElements = document.querySelectorAll('.fill-option');
    fillOptionsElements.forEach(element => {
        if (element.textContent === option && element.classList.contains('used')) {
            element.classList.remove('used');
            element.style.cursor = 'pointer';
        }
    });
    
    // Удаляем из списка выбранных
    if (selectedAnswersDiv) {
        const answers = selectedAnswersDiv.querySelectorAll('.selected-answer');
        answers.forEach(answer => {
            if (answer.textContent.includes(`Пропуск ${blankId}: ${option}`)) {
                answer.remove();
            }
        });
    }
    
    // Обновляем кнопку проверки
    const blanks = document.querySelectorAll('.blank');
    const allFilled = Array.from(blanks).every(blank => blank.textContent !== '_____');
    if (checkFillBtn) {
        checkFillBtn.disabled = !allFilled;
    }
}

function checkFillAnswer() {
    const fillItem = randomFillData[currentFillIndex];
    let allCorrect = true;
    
    // Проверяем каждый пропуск
    fillItem.blanks.forEach(blank => {
        const blankElement = document.querySelector(`.blank[data-id="${blank.id}"]`);
        const userAnswer = selectedBlanks[blank.id];
        
        if (userAnswer === blank.correct) {
            // Правильный ответ
            blankElement.style.color = '#4cc9f0';
            blankElement.style.backgroundColor = 'rgba(76, 201, 240, 0.1)';
            blankElement.style.padding = '2px 5px';
            blankElement.style.borderRadius = '4px';
        } else {
            // Неправильный ответ
            blankElement.style.color = '#f94144';
            blankElement.style.backgroundColor = 'rgba(249, 65, 68, 0.1)';
            blankElement.style.padding = '2px 5px';
            blankElement.style.borderRadius = '4px';
            blankElement.innerHTML = `${userAnswer} <span style="color: #4cc9f0; font-weight: normal;">(правильно: ${blank.correct})</span>`;
            allCorrect = false;
        }
    });
    
    // Показываем обратную связь
    if (fillFeedback) {
        if (allCorrect) {
            fillFeedback.innerHTML = `
                <div style="text-align: center;">
                    <i class="fas fa-check-circle" style="font-size: 2rem; color: #4cc9f0; margin-bottom: 10px;"></i>
                    <p style="font-weight: bold; color: #4cc9f0;">Правильно! Все пропуски заполнены верно.</p>
                </div>
            `;
            fillFeedback.style.backgroundColor = 'rgba(76, 201, 240, 0.1)';
            correctFills++;
        } else {
            fillFeedback.innerHTML = `
                <div style="text-align: center;">
                    <i class="fas fa-times-circle" style="font-size: 2rem; color: #f94144; margin-bottom: 10px;"></i>
                    <p style="font-weight: bold; color: #f94144;">Есть ошибки! Проверьте правильные ответы выше.</p>
                </div>
            `;
            fillFeedback.style.backgroundColor = 'rgba(249, 65, 68, 0.1)';
        }
    }
    
    if (checkFillBtn) checkFillBtn.disabled = true;
    if (nextFillBtn) nextFillBtn.disabled = false;
    
    // Обновляем статистику
    if (filledCountSpan) filledCountSpan.textContent = correctFills;
    
    saveProgress();
}

function nextFillQuestion() {
    currentFillIndex++;
    
    if (currentFillIndex >= randomFillData.length) {
        currentFillIndex = 0;
    }
    
    selectedBlanks = {};
    loadFillQuestion(currentFillIndex);
    saveProgress();
}

function showFillHint() {
    const fillItem = randomFillData[currentFillIndex];
    
    // Находим первый незаполненный пропуск
    const blanks = document.querySelectorAll('.blank');
    let blankToHint = null;
    
    for (const blank of blanks) {
        if (blank.textContent === '_____') {
            blankToHint = blank;
            break;
        }
    }
    
    if (blankToHint) {
        const blankId = blankToHint.dataset.id;
        const correctBlank = fillItem.blanks.find(b => b.id == blankId);
        
        if (correctBlank) {
            // Находим элемент с правильным ответом среди вариантов
            const fillOptionsElements = document.querySelectorAll('.fill-option');
            const correctOptionElement = Array.from(fillOptionsElements).find(
                element => element.textContent === correctBlank.correct && !element.classList.contains('used')
            );
            
            if (correctOptionElement) {
                // Подсвечиваем правильный вариант на 3 секунды
                const originalBg = correctOptionElement.style.backgroundColor;
                const originalBorder = correctOptionElement.style.border;
                correctOptionElement.style.backgroundColor = 'rgba(76, 201, 240, 0.3)';
                correctOptionElement.style.border = '2px solid #4cc9f0';
                
                setTimeout(() => {
                    correctOptionElement.style.backgroundColor = originalBg;
                    correctOptionElement.style.border = originalBorder;
                }, 3000);
                
                showNotification(`Подсказка: подсвечен правильный вариант для пропуска ${blankId}`, 'info');
            }
        }
    } else {
        showNotification('Все пропуски уже заполнены!', 'info');
    }
}

function clearFillSelections() {
    // Очищаем все выборы
    selectedBlanks = {};
    
    // Восстанавливаем все пропуски
    const blanks = document.querySelectorAll('.blank');
    blanks.forEach(blank => {
        blank.textContent = '_____';
        blank.style.color = '';
        blank.style.backgroundColor = '';
        blank.style.padding = '';
        blank.style.borderRadius = '';
        blank.innerHTML = '_____';
    });
    
    // Восстанавливаем все варианты
    const fillOptionsElements = document.querySelectorAll('.fill-option');
    fillOptionsElements.forEach(element => {
        element.classList.remove('used', 'selected');
        element.style.cursor = 'pointer';
        element.style.backgroundColor = '';
        element.style.border = '';
    });
    
    // Очищаем список выбранных
    if (selectedAnswersDiv) selectedAnswersDiv.innerHTML = '';
    
    // Обновляем кнопки
    if (checkFillBtn) checkFillBtn.disabled = false;
    if (nextFillBtn) nextFillBtn.disabled = true;
    
    // Очищаем обратную связь
    if (fillFeedback) {
        fillFeedback.innerHTML = '<p>Выберите правильный вариант для каждого пропуска в тексте.</p>';
        fillFeedback.style.backgroundColor = '#f8f9fa';
    }
    
    showNotification('Все выборы очищены', 'info');
}

// ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====

function showNotification(message, type = 'info') {
    // Создаем уведомление
    const notification = document.createElement('div');
    notification.className = `notification notification-${type}`;
    
    let icon = 'fa-info-circle';
    switch (type) {
        case 'success': icon = 'fa-check-circle'; break;
        case 'warning': icon = 'fa-exclamation-circle'; break;
        case 'error': icon = 'fa-times-circle'; break;
    }
    
    notification.innerHTML = `
        <div class="notification-content">
            <i class="fas ${icon}"></i>
            <span>${message}</span>
        </div>
    `;
    
    // Добавляем стили
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4cc9f0' : type === 'warning' ? '#f8961e' : type === 'error' ? '#f94144' : '#4361ee'};
        color: white;
        padding: 15px 20px;
        border-radius: 8px;
        box-shadow: 0 5px 20px rgba(0,0,0,0.2);
        z-index: 1000;
        animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s;
        max-width: 300px;
        display: flex;
        align-items: center;
        gap: 10px;
        font-weight: 500;
    `;
    
    document.body.appendChild(notification);
    
    // Удаляем через 3 секунды
    setTimeout(() => {
        if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
        }
    }, 3000);
}

// Добавляем CSS для анимаций уведомлений
const notificationStyles = document.createElement('style');
notificationStyles.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes fadeOut {
        from {
            opacity: 1;
        }
        to {
            opacity: 0;
        }
    }
`;
document.head.appendChild(notificationStyles);

// Экспортируем функции для глобального использования
window.resetMatchingGame = resetMatchingGame;
window.removeFillSelection = removeFillSelection;
// Дополнительные функции для мобильной версии

function setupMobileOptimizations() {
    // Обработка касаний для улучшенного UX
    if ('ontouchstart' in window) {
        // Улучшаем обратную связь при касании
        document.querySelectorAll('.answer-option, .match-item, .fill-option').forEach(el => {
            el.addEventListener('touchstart', function() {
                this.classList.add('touch-active');
            });
            
            el.addEventListener('touchend', function() {
                this.classList.remove('touch-active');
            });
        });
    }
    
    // Предотвращение масштабирования при двойном тапе
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function(event) {
        const now = Date.now();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);
    
    // Улучшение работы выпадающих списков на мобильных
    const selectElements = document.querySelectorAll('select');
    selectElements.forEach(select => {
        select.addEventListener('touchstart', function(e) {
            e.stopPropagation();
        });
    });
    
    // Адаптация высоты текстовых элементов
    function adjustMobileLayout() {
        const isMobile = window.innerWidth <= 768;
        
        if (isMobile) {
            // Устанавливаем минимальную высоту для лучшего UX
            document.querySelectorAll('.answer-option').forEach(el => {
                el.style.minHeight = '44px';
            });
            
            document.querySelectorAll('.btn').forEach(el => {
                el.style.minHeight = '48px';
                el.style.display = 'flex';
                el.style.alignItems = 'center';
                el.style.justifyContent = 'center';
            });
            
            // Улучшаем отображение карточек
            const flashCard = document.getElementById('flash-card');
            if (flashCard) {
                flashCard.style.minHeight = '250px';
            }
        }
    }
    
    // Выполняем при загрузке и при изменении размера
    adjustMobileLayout();
    window.addEventListener('resize', adjustMobileLayout);
}

// Добавьте вызов функции в конец DOMContentLoaded
document.addEventListener('DOMContentLoaded', function() {
    // ... существующий код ...
    
    // Инициализация мобильных оптимизаций
    setupMobileOptimizations();
    
    // Открытие/закрытие бокового меню
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn');
    const mobileMenu = document.getElementById('mobile-menu');
    const mobileMenuOverlay = document.getElementById('mobile-menu-overlay');
    
    if (mobileMenuBtn && mobileMenu && mobileMenuOverlay) {
        mobileMenuBtn.addEventListener('click', () => {
            mobileMenu.classList.add('show');
            mobileMenuOverlay.style.display = 'block';
            setTimeout(() => {
                mobileMenuOverlay.style.opacity = '1';
            }, 10);
        });
        
        mobileMenuOverlay.addEventListener('click', () => {
            mobileMenu.classList.remove('show');
            mobileMenuOverlay.style.opacity = '0';
            setTimeout(() => {
                mobileMenuOverlay.style.display = 'none';
            }, 300);
        });
        
        // Закрытие по кнопке в меню
        const mobileMenuClose = document.querySelector('.mobile-menu-close');
        if (mobileMenuClose) {
            mobileMenuClose.addEventListener('click', () => {
                mobileMenu.classList.remove('show');
                mobileMenuOverlay.style.opacity = '0';
                setTimeout(() => {
                    mobileMenuOverlay.style.display = 'none';
                }, 300);
            });
        }
    }
});